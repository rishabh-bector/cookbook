{"remainingRequest":"/Users/rbector/Desktop/cookbook/node_modules/babel-loader/lib/index.js!/Users/rbector/Desktop/cookbook/node_modules/ts-loader/index.js??ref--14-2!/Users/rbector/Desktop/cookbook/node_modules/eslint-loader/index.js??ref--13-0!/Users/rbector/Desktop/cookbook/src/logic/parser.ts","dependencies":[{"path":"/Users/rbector/Desktop/cookbook/src/logic/parser.ts","mtime":1594774297954},{"path":"/Users/rbector/Desktop/cookbook/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/rbector/Desktop/cookbook/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/rbector/Desktop/cookbook/node_modules/ts-loader/index.js","mtime":499162500000},{"path":"/Users/rbector/Desktop/cookbook/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5pbmRleC1vZiI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmpvaW4iOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5uYW1lIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmV4ZWMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuaW5jbHVkZXMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbSI7CmltcG9ydCB7IFVuaXQsIFVuaXRTdHJpbmdzLCBGcmFjTWFwIH0gZnJvbSAiLi4vY29tbW9uL2NvbW1vbiI7CmV4cG9ydCBmdW5jdGlvbiBQYXJzZVVuaXQodG9rZW4pIHsKICB2YXIgcHJvY2Vzc2VkID0gdG9rZW4udG9Mb3dlckNhc2UoKTsKCiAgdmFyIGRvZXNJbmNsdWRlQXJyYXkgPSBmdW5jdGlvbiBkb2VzSW5jbHVkZUFycmF5KGlucHV0LCB0ZXJtcykgewogICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKykgewogICAgICBpZiAoaW5wdXQuaW5jbHVkZXModGVybXNbaV0pKSByZXR1cm4gdHJ1ZTsKICAgIH0KCiAgICByZXR1cm4gZmFsc2U7CiAgfTsgLy8gVm9sdW1lCgoKICBpZiAoZG9lc0luY2x1ZGVBcnJheShwcm9jZXNzZWQsIFVuaXRTdHJpbmdzLmN1cCkpIHJldHVybiBVbml0LkN1cDsKICBpZiAoZG9lc0luY2x1ZGVBcnJheShwcm9jZXNzZWQsIFVuaXRTdHJpbmdzLnRhYmxlc3Bvb24pKSByZXR1cm4gVW5pdC5UYWJsZXNwb29uOwogIGlmIChkb2VzSW5jbHVkZUFycmF5KHByb2Nlc3NlZCwgVW5pdFN0cmluZ3MudGVhc3Bvb24pKSByZXR1cm4gVW5pdC5UZWFzcG9vbjsKICBpZiAoZG9lc0luY2x1ZGVBcnJheShwcm9jZXNzZWQsIFVuaXRTdHJpbmdzLmZsdWlkb3VuY2UpKSByZXR1cm4gVW5pdC5GbHVpZE91bmNlOyAvLyBNYXNzCgogIGlmIChkb2VzSW5jbHVkZUFycmF5KHByb2Nlc3NlZCwgVW5pdFN0cmluZ3Mub3VuY2UpKSByZXR1cm4gVW5pdC5PdW5jZTsKICBpZiAoZG9lc0luY2x1ZGVBcnJheShwcm9jZXNzZWQsIFVuaXRTdHJpbmdzLnBvdW5kKSkgcmV0dXJuIFVuaXQuUG91bmQ7CiAgaWYgKGRvZXNJbmNsdWRlQXJyYXkocHJvY2Vzc2VkLCBVbml0U3RyaW5ncy5raWxvZ3JhbSkpIHJldHVybiBVbml0LktpbG9ncmFtOwogIGlmIChkb2VzSW5jbHVkZUFycmF5KHByb2Nlc3NlZCwgVW5pdFN0cmluZ3MubWlsbGlncmFtKSkgcmV0dXJuIFVuaXQuTWlsbGlncmFtOwogIHJldHVybiBVbml0Lk5vbmU7Cn0KCmZ1bmN0aW9uIGlzUXVhbnRpdHkodG9rZW4pIHsKICB2YXIgY2hhcnMgPSB0b2tlbi5zcGxpdCgiIik7CgogIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHsKICAgIGlmIChjaGFyc1tpXSBpbiBGcmFjTWFwKSB7CiAgICAgIGNvbnRpbnVlOwogICAgfQoKICAgIGlmIChpc05hTihOdW1iZXIoY2hhcnNbaV0pKSAmJiBjaGFyc1tpXSAhPT0gIi8iICYmIGNoYXJzW2ldICE9PSAiLiIpIHJldHVybiBmYWxzZTsKICB9CgogIHJldHVybiB0cnVlOwp9CgpmdW5jdGlvbiBwYXJzZVF1YW50aXR5KHRva2VuKSB7CiAgdmFyIGNoYXJzID0gdG9rZW4uc3BsaXQoIiIpOwogIHZhciBzaG91bGRFdmFsID0gZmFsc2U7CgogIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnMubGVuZ3RoOyBpKyspIHsKICAgIGlmIChjaGFyc1tpXSBpbiBGcmFjTWFwKSB7CiAgICAgIGNoYXJzW2ldID0gRnJhY01hcFtjaGFyc1tpXV07CiAgICAgIHNob3VsZEV2YWwgPSB0cnVlOwogICAgfQogIH0KCiAgaWYgKHNob3VsZEV2YWwpIHsKICAgIHZhciBqb2luZWQgPSBjaGFycy5qb2luKCIrIik7CiAgICByZXR1cm4gTnVtYmVyKGV2YWwoam9pbmVkKSk7CiAgfQoKICBpZiAodG9rZW4uaW5jbHVkZXMoIi8iKSkgewogICAgdmFyIGZyYWMgPSB0b2tlbi5zcGxpdCgiLyIpOwogICAgcmV0dXJuIE51bWJlcihmcmFjWzBdKSAvIE51bWJlcihmcmFjWzFdKTsKICB9CgogIHJldHVybiBOdW1iZXIodG9rZW4pOwp9CgpleHBvcnQgZnVuY3Rpb24gUGFyc2VMaW5lKGxpbmUpIHsKICB2YXIgaW5ncmVkaWVudCA9IHsKICAgIG5hbWU6ICIiLAogICAgcXVhbnRpdHk6IDAsCiAgICB1bml0OiBVbml0Lk5vbmUKICB9OwogIHZhciB0b2tlbnMgPSBsaW5lLnRyaW0oKS5zcGxpdCgiICIpOwoKICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykgewogICAgLy8gUXVhbnRpdHkKICAgIGlmIChpc1F1YW50aXR5KHRva2Vuc1tpXSkpIHsKICAgICAgaW5ncmVkaWVudC5xdWFudGl0eSA9IHBhcnNlUXVhbnRpdHkodG9rZW5zW2ldKTsKICAgICAgY29udGludWU7CiAgICB9IC8vIFVuaXQKCgogICAgdmFyIHBhcnNlZFVuaXQgPSBQYXJzZVVuaXQodG9rZW5zW2ldKTsKCiAgICBpZiAocGFyc2VkVW5pdCAhPSBVbml0Lk5vbmUpIHsKICAgICAgaW5ncmVkaWVudC51bml0ID0gcGFyc2VkVW5pdDsKICAgICAgY29udGludWU7CiAgICB9IC8vIE5hbWUKCgogICAgaW5ncmVkaWVudC5uYW1lICs9IHRva2Vuc1tpXSArICIgIjsKICB9CgogIGluZ3JlZGllbnQubmFtZSA9IGluZ3JlZGllbnQubmFtZS50cmltKCk7CgogIGlmIChpbmdyZWRpZW50Lm5hbWUuaW5jbHVkZXMoIiwiKSkgewogICAgaW5ncmVkaWVudC5uYW1lID0gaW5ncmVkaWVudC5uYW1lLnN1YnN0cmluZygwLCBpbmdyZWRpZW50Lm5hbWUuaW5kZXhPZigiLCIpKTsKICB9CgogIHJldHVybiBpbmdyZWRpZW50Owp9"},{"version":3,"sources":["/Users/rbector/Desktop/cookbook/node_modules/eslint-loader/index.js??ref--13-0!/Users/rbector/Desktop/cookbook/src/logic/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  IngredientData,\n  Unit,\n  UnitStrings,\n  FracMap\n} from \"../common/common\";\n\nexport function ParseUnit(token: string): Unit {\n  const processed = token.toLowerCase();\n  const doesIncludeArray = (input: string, terms: string[]): boolean => {\n    for (let i = 0; i < terms.length; i++) {\n      if (input.includes(terms[i])) return true;\n    }\n    return false;\n  };\n\n  // Volume\n  if (doesIncludeArray(processed, UnitStrings.cup)) return Unit.Cup;\n  if (doesIncludeArray(processed, UnitStrings.tablespoon)) return Unit.Tablespoon;\n  if (doesIncludeArray(processed, UnitStrings.teaspoon)) return Unit.Teaspoon;\n  if (doesIncludeArray(processed, UnitStrings.fluidounce)) return Unit.FluidOunce;\n\n  // Mass\n  if (doesIncludeArray(processed, UnitStrings.ounce)) return Unit.Ounce;\n  if (doesIncludeArray(processed, UnitStrings.pound)) return Unit.Pound;\n  if (doesIncludeArray(processed, UnitStrings.kilogram)) return Unit.Kilogram;\n  if (doesIncludeArray(processed, UnitStrings.milligram)) return Unit.Milligram;\n\n  return Unit.None;\n}\n\nfunction isQuantity(token: string): boolean {\n  const chars = token.split(\"\");\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] in FracMap) {\n      continue;\n    }\n    if (isNaN(Number(chars[i])) && chars[i] !== \"/\" && chars[i] !== \".\")\n      return false;\n  }\n  return true;\n}\n\nfunction parseQuantity(token: string): number {\n  const chars = token.split(\"\");\n  let shouldEval = false;\n  for (let i = 0; i < chars.length; i++) {\n    if (chars[i] in FracMap) {\n      chars[i] = FracMap[chars[i]];\n      shouldEval = true;\n    }\n  }\n  if (shouldEval) {\n    const joined = chars.join(\"+\");\n    return Number(eval(joined));\n  }\n  if (token.includes(\"/\")) {\n    const frac = token.split(\"/\");\n    return Number(frac[0]) / Number(frac[1]);\n  }\n  return Number(token);\n}\n\nexport function ParseLine(line: string): IngredientData {\n  const ingredient = {\n    name: \"\",\n    quantity: 0,\n    unit: Unit.None\n  };\n\n  const tokens = line.trim().split(\" \");\n  for (let i = 0; i < tokens.length; i++) {\n    // Quantity\n    if (isQuantity(tokens[i])) {\n      ingredient.quantity = parseQuantity(tokens[i]);\n      continue;\n    }\n    \n    // Unit\n    const parsedUnit = ParseUnit(tokens[i]);\n    if (parsedUnit != Unit.None) {\n      ingredient.unit = parsedUnit;\n      continue;\n    }\n\n    // Name\n    ingredient.name += tokens[i] + \" \";\n  }\n\n  ingredient.name = ingredient.name.trim();\n  if (ingredient.name.includes(\",\")) {\n    ingredient.name = ingredient.name.substring(\n      0,\n      ingredient.name.indexOf(\",\")\n    );\n  }\n\n  return ingredient;\n}"],"sourceRoot":""}]}